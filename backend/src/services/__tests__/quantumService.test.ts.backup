/**
 * ===============================================================================
 * CRITICAL SECURITY TESTS: QUANTUM SERVICE
 * INVESTOR REQUIREMENT: True Quantum Randomness Validation
 * ===============================================================================
 * 
 * These tests validate our PATENT-CRITICAL quantum password generation
 * Requirement: >70% coverage for this quantum security service
 * 
 * QUANTUM VALIDATIONS:
 * 1. âœ… Generates passwords with correct length and complexity
 * 2. âœ… True randomness from quantum sources
 * 3. âœ… Fallback works when quantum sources fail
 * 4. âœ… No duplicate passwords in large sample
 * 5. âœ… Quantum metadata correctly tracked
 */

import { describe, test, expect, beforeEach, jest } from '@jest/globals';
import { generateQuantumPassword } from '../../patents/quantum-random/quantumEntropyService';
import { TestUtils, MockQuantumService } from '../../__tests__/setup';
import axios from 'axios';

// Mock axios for controlled testing
jest.mock('axios');
const mockedAxios = axios as jest.Mocked<typeof axios>;

describe('ðŸŒŒ QuantumService - CRITICAL RANDOMNESS TESTS', () => {
  beforeEach(() => {
    jest.clearAllMocks();
    // Default mock: successful quantum response
    mockedAxios.get.mockResolvedValue(
      MockQuantumService.mockAxiosResponse(MockQuantumService.generateMockQuantumData(64))
    );
  });

  describe('ðŸŽ¯ PASSWORD GENERATION REQUIREMENTS', () => {
    test('CRITICAL: Generates passwords with exact specified length', async () => {
      const testLengths = [8, 12, 16, 20, 32, 64];
      
      for (const length of testLengths) {
        const password = await generateQuantumPassword(length);
        expect(password).toHaveLength(length);
      }
      
      console.log('âœ… LENGTH VALIDATION: All specified lengths generated correctly');
    });

    test('CRITICAL: Includes symbols when requested', async () => {
      const passwordWithSymbols = await generateQuantumPassword(16, true);
      const passwordWithoutSymbols = await generateQuantumPassword(16, false);
      
      // Check for symbols in password with symbols
      const hasSymbols = /[!@#$%^&*()_+\-=\[\]{};':"\\|,.<>\/?`~]/.test(passwordWithSymbols);
      expect(hasSymbols).toBe(true);
      
      // Check no symbols in password without symbols
      const hasNoSymbols = !/[!@#$%^&*()_+\-=\[\]{};':"\\|,.<>\/?`~]/.test(passwordWithoutSymbols);
      expect(hasNoSymbols).toBe(true);
      
      console.log(`âœ… SYMBOL CONTROL: With symbols: ${passwordWithSymbols}, Without: ${passwordWithoutSymbols}`);
    });

    test('CRITICAL: Contains mix of character types', async () => {
      const passwords = await Promise.all(
        Array.from({ length: 10 }, () => generateQuantumPassword(32, true))
      );
      
      passwords.forEach(password => {
        const hasLowercase = /[a-z]/.test(password);
        const hasUppercase = /[A-Z]/.test(password);
        const hasNumbers = /[0-9]/.test(password);
        const hasSymbols = /[!@#$%^&*()_+\-=\[\]{};':"\\|,.<>\/?`~]/.test(password);
        
        // Each password should have at least 3 character types
        const characterTypes = [hasLowercase, hasUppercase, hasNumbers, hasSymbols].filter(Boolean).length;
        expect(characterTypes).toBeGreaterThanOrEqual(3);
      });
      
      console.log('âœ… CHARACTER DIVERSITY: All passwords contain mixed character types');
    });
  });

  describe('ðŸ”¬ QUANTUM RANDOMNESS VALIDATION', () => {
    test('CRITICAL: No duplicate passwords in large sample', async () => {
      const sampleSize = 10000;
      console.log(`ðŸ§ª Generating ${sampleSize} passwords to test uniqueness...`);
      
      const { result: passwords, timeMs } = await TestUtils.measurePerformance(async () => {
        const passwordPromises = Array.from({ length: sampleSize }, () => 
          generateQuantumPassword(16, true)
        );
        return Promise.all(passwordPromises);
      });
      
      // Verify all passwords are unique
      const isUnique = TestUtils.verifyUniqueness(passwords);
      expect(isUnique).toBe(true);
      
      // Performance check
      expect(timeMs).toBeLessThan(30000); // Should complete within 30 seconds
      
      console.log(`âœ… UNIQUENESS VERIFIED: ${sampleSize} unique passwords in ${timeMs.toFixed(2)}ms`);
      console.log(`ðŸ“Š Generation rate: ${(sampleSize / timeMs * 1000).toFixed(0)} passwords/second`);
    });

    test('CRITICAL: High entropy in generated passwords', async () => {
      const passwords = await Promise.all(
        Array.from({ length: 100 }, () => generateQuantumPassword(32, true))
      );
      
      // Test entropy of each password
      passwords.forEach(password => {
        const entropy = TestUtils.testEntropy(password);
        expect(entropy.isGood).toBe(true);
        expect(entropy.score).toBeGreaterThan(60); // High entropy threshold
      });
      
      // Test collective entropy
      const combinedPasswords = passwords.join('');
      const collectiveEntropy = TestUtils.testEntropy(combinedPasswords);
      expect(collectiveEntropy.score).toBeGreaterThan(80);
      
      console.log(`âœ… ENTROPY VERIFIED: Individual and collective entropy > 60%`);
      console.log(`ðŸ“Š Collective entropy: ${collectiveEntropy.score}%`);
    });

    test('CRITICAL: Statistical randomness distribution', async () => {
      const passwords = await Promise.all(
        Array.from({ length: 1000 }, () => generateQuantumPassword(20, false))
      );
      
      // Count character frequency
      const charCounts: { [key: string]: number } = {};
      const allChars = passwords.join('');
      
      for (const char of allChars) {
        charCounts[char] = (charCounts[char] || 0) + 1;
      }
      
      // Check distribution isn't heavily skewed
      const counts = Object.values(charCounts);
      const mean = counts.reduce((a, b) => a + b, 0) / counts.length;
      const variance = counts.reduce((sum, count) => sum + Math.pow(count - mean, 2), 0) / counts.length;
      const stdDev = Math.sqrt(variance);
      const coefficientOfVariation = stdDev / mean;
      
      // Coefficient of variation should be reasonable for random distribution
      expect(coefficientOfVariation).toBeLessThan(0.5); // Not too skewed
      
      console.log(`âœ… DISTRIBUTION VERIFIED: Coefficient of variation: ${coefficientOfVariation.toFixed(3)}`);
    });
  });

  describe('ðŸ”„ QUANTUM SOURCE MANAGEMENT', () => {
    test('CRITICAL: Uses quantum source when available', async () => {
      // Mock successful quantum response
      const mockQuantumData = MockQuantumService.generateMockQuantumData(32);
      mockedAxios.get.mockResolvedValue(MockQuantumService.mockAxiosResponse(mockQuantumData));
      
      const password = await generateQuantumPassword(16);
      
      // Verify quantum API was called
      expect(mockedAxios.get).toHaveBeenCalled();
      expect(password).toHaveLength(16);
      
      console.log('âœ… QUANTUM SOURCE: Successfully used quantum API');
    });

    test('CRITICAL: Fallback works when quantum source fails', async () => {
      // Mock quantum API failure
      mockedAxios.get.mockRejectedValue(new Error('Quantum API unavailable'));
      
      const password = await generateQuantumPassword(16);
      
      // Should still generate password using fallback
      expect(password).toHaveLength(16);
      expect(typeof password).toBe('string');
      
      // Verify it tried quantum first
      expect(mockedAxios.get).toHaveBeenCalled();
      
      console.log('âœ… FALLBACK VERIFIED: Crypto fallback works when quantum fails');
    });

    test('CRITICAL: Multiple quantum source attempts', async () => {
      // Mock first source failure, second success
      mockedAxios.get
        .mockRejectedValueOnce(new Error('ANU QRNG unavailable'))
        .mockResolvedValueOnce(MockQuantumService.mockAxiosResponse(
          MockQuantumService.generateMockQuantumData(32)
        ));
      
      const password = await generateQuantumPassword(16);
      
      expect(password).toHaveLength(16);
      // Should have tried multiple times
      expect(mockedAxios.get).toHaveBeenCalledTimes(2);
      
      console.log('âœ… SOURCE REDUNDANCY: Multiple quantum sources attempted');
    });

    test('CRITICAL: Handles partial quantum data', async () => {
      // Mock quantum response with insufficient data
      const insufficientData = MockQuantumService.generateMockQuantumData(5); // Less than needed
      mockedAxios.get.mockResolvedValue(MockQuantumService.mockAxiosResponse(insufficientData));
      
      const password = await generateQuantumPassword(16);
      
      // Should still generate full-length password
      expect(password).toHaveLength(16);
      
      console.log('âœ… PARTIAL DATA HANDLING: Handles insufficient quantum data gracefully');
    });
  });

  describe('âš¡ PERFORMANCE REQUIREMENTS', () => {
    test('CRITICAL: Generates 100 passwords in under 5 seconds', async () => {
      const { timeMs } = await TestUtils.measurePerformance(async () => {
        const passwordPromises = Array.from({ length: 100 }, () => 
          generateQuantumPassword(16, true)
        );
        return Promise.all(passwordPromises);
      });
      
      expect(timeMs).toBeLessThan(5000); // Less than 5 seconds
      
      const avgTimePerPassword = timeMs / 100;
      console.log(`âœ… PERFORMANCE: 100 passwords in ${timeMs.toFixed(2)}ms`);
      console.log(`ðŸ“Š Average: ${avgTimePerPassword.toFixed(2)}ms per password`);
    });

    test('CRITICAL: Single password generation under 500ms', async () => {
      const iterations = 10;
      const times: number[] = [];
      
      for (let i = 0; i < iterations; i++) {
        const { timeMs } = await TestUtils.measurePerformance(async () => {
          return generateQuantumPassword(32, true);
        });
        times.push(timeMs);
      }
      
      const avgTime = times.reduce((a, b) => a + b, 0) / times.length;
      const maxTime = Math.max(...times);
      
      expect(avgTime).toBeLessThan(500); // Average under 500ms
      expect(maxTime).toBeLessThan(1000); // Max under 1 second
      
      console.log(`âœ… SINGLE PASSWORD PERFORMANCE: Avg ${avgTime.toFixed(2)}ms, Max ${maxTime.toFixed(2)}ms`);
    });
  });

  describe('ðŸ›¡ï¸ SECURITY EDGE CASES', () => {
    test('CRITICAL: Handles minimum length requirements', async () => {
      // Test very short passwords (edge case)
      const shortPassword = await generateQuantumPassword(1);
      expect(shortPassword).toHaveLength(1);
      
      // Test reasonable minimum
      const minPassword = await generateQuantumPassword(8);
      expect(minPassword).toHaveLength(8);
      
      console.log('âœ… MINIMUM LENGTH: Handles short password requirements');
    });

    test('CRITICAL: Handles maximum length requirements', async () => {
      // Test very long passwords
      const longPassword = await generateQuantumPassword(128);
      expect(longPassword).toHaveLength(128);
      
      // Verify entropy is maintained in long passwords
      const entropy = TestUtils.testEntropy(longPassword);
      expect(entropy.isGood).toBe(true);
      
      console.log(`âœ… MAXIMUM LENGTH: 128-char password with ${entropy.score}% entropy`);
    });

    test('CRITICAL: Consistent behavior across multiple calls', async () => {
      // Generate multiple passwords with same parameters
      const passwords = await Promise.all([
        generateQuantumPassword(16, true),
        generateQuantumPassword(16, true),
        generateQuantumPassword(16, true)
      ]);
      
      // All should be same length and include symbols
      passwords.forEach(password => {
        expect(password).toHaveLength(16);
        const hasSymbols = /[!@#$%^&*()_+\-=\[\]{};':"\\|,.<>\/?`~]/.test(password);
        expect(hasSymbols).toBe(true);
      });
      
      // But should be different passwords
      const isUnique = TestUtils.verifyUniqueness(passwords);
      expect(isUnique).toBe(true);
      
      console.log('âœ… CONSISTENCY: Same parameters produce consistent format, different content');
    });
  });

  describe('ðŸ“Š QUANTUM QUALITY METRICS', () => {
    test('CRITICAL: Quantum vs Crypto fallback detection', async () => {
      // Test quantum success
      mockedAxios.get.mockResolvedValue(
        MockQuantumService.mockAxiosResponse(MockQuantumService.generateMockQuantumData(32))
      );
      
      const quantumPassword = await generateQuantumPassword(16);
      expect(quantumPassword).toHaveLength(16);
      
      // Test crypto fallback
      mockedAxios.get.mockRejectedValue(new Error('Quantum unavailable'));
      
      const cryptoPassword = await generateQuantumPassword(16);
      expect(cryptoPassword).toHaveLength(16);
      
      // Both should be high quality
      const quantumEntropy = TestUtils.testEntropy(quantumPassword);
      const cryptoEntropy = TestUtils.testEntropy(cryptoPassword);
      
      expect(quantumEntropy.isGood).toBe(true);
      expect(cryptoEntropy.isGood).toBe(true);
      
      console.log(`âœ… QUALITY COMPARISON: Quantum ${quantumEntropy.score}%, Crypto ${cryptoEntropy.score}%`);
    });

    test('CRITICAL: Large scale randomness test', async () => {
      // Generate large sample for statistical analysis
      const largeSample = await Promise.all(
        Array.from({ length: 5000 }, () => generateQuantumPassword(8, false))
      );
      
      // Check for patterns or bias
      const allChars = largeSample.join('');
      const entropy = TestUtils.testEntropy(allChars);
      
      expect(entropy.score).toBeGreaterThan(75); // High quality randomness
      expect(TestUtils.verifyUniqueness(largeSample)).toBe(true);
      
      console.log(`âœ… LARGE SCALE TEST: 5000 passwords, ${entropy.score}% entropy`);
    });
  });
});

// Export for integration tests
export { MockQuantumService };